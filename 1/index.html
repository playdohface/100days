<!DOCTYPE html>
<html>
	
	<head>
		<style>
		body {
			max-width: 50em;
			font-family: Georgia, serif;
		}
		time {
			font-size: .8em;
		}
		</style>
	</head>
	<body>
		<article>
			<h1>100 Days</h1><time datetime="2022-26-02">February 26th, 2023</time>
			<p>I was recently inspired by the 100 Days of Code challenge. I am a big believer in ongoing improvement. Doing things daily. And I figured I'd start by writing semantic HTML first. I also figured I would take this opportunity to learn Vim in depth - because, while I have a servicable knowledge of vim for doing quick edits from the command line, I am not at all accustomed to vim bindings.  
			</p>
			<p>My objective with this is that it may become my work.
			Until recently, I have been a musician and sound engineer.
			I've created several albums per year, worked in many groups, organised and played on tours, plugged cables in the studio, done editing, mixing, mastering.
			I play 4 instruments on a professional level, and speak 5 languages fluently.
			I did 60 hour weeks of work that was demanding both mentally and physically, without sick leave or holidays.
			And I made enough money to barely afford a simple life.
			Not to be misunderstood, I do not regret any of it.
			The musician life is its own reward, and I have learned many things, many of which I could not have learned any other way.
			But when last summer, after a tour, I came home exhausted I realized that it was time to for new challenges.</p> 
			<p>The challenge of computer programming was not completely new to me even then.
			I grew up with computers.
			My father had recognized early how computers are going to shape the world going forward, and so he made sure that his kids would be proficient in using them.
			So I had a computer in my room starting at the age of 7, this was 1994.
			It was an Intel 386 I believe, 4 MB of RAM and a 100 MB Hard Drive.
			I remember installing games, from a dozen or so floppy disks, and editing shell scripts in order to get sound drivers working.
			I remember the way the computer would hum, and the screeching sound of the floppy drive. 
			I wrote my first 'Hello World' a couple of years later.
			I had a book, titled 'C++ in 21 Days'.
			Unfortunately, at the time, I had neither teacher nor resources about actual programming, so I never got very far.
			Then we got the internet.
			I still wasn't fluent in english at the time (neither were my english teachers in school) so the resources available to me were not actually that plentiful, but it was enough to teach myself about making websites.
			I made table-layouts with spacer-gifs and built fan pages for my favorite computer games.
			I made things with Flash and ActionScript.
			In my early twenties, I built a website with Joomla (called the jazz education database, a place where people could find and share their jazz solo transciptions) that had a couple of hundred daily visitors at some point, but I did not have time to properly maintain it.
			Shortly after I discovered Python, and did some programming projects whenever I had some time off.
			But it was never enough to go deeply into it.
			Until last summer.</p>
			<p>After soldiering through the [pandemic years and realizing that post-pandemic the situation for musicias had gotten even worse than <em>during</em> the pandemic, I decided to make a change.
			I started learning to code with a serious, professional attitude.
			My starting point was naturally Python, as I was already quite familiar with the language, so I picked up Django.
			The good thing about Django, it makes backend development seem very easy as long as you are not doing anything fancy.
			But beyond the very basics, there is not much point in learning Django deeply unless you are working on a project that uses Django (which I would advise against for reasons having nothing to do with the quality of Django as a framework), because you will spend most of your energy on learning about the specific abstractions that Django uses instead of the underlying technology.
			With Django, you'll have a full stack web app running, with a Database and everything, without writing a single line of SQL or even understanding HTTP.
			I also learned that it would be a good idea to focus on frontend to start with. So next I dusted off my JavaScript and worked my way through Angular.
			I found it to be a fine toolset for many common use-cases.
			The opinionated nature may make it feel a little bit heavy for a lot of tasks, and with Angular as with Django you feel a little bit too far removed from whats actually going on, but you get a lot of best practices for free. After spending way too much time on Emacs and org-mode, exploring things like literate programming and various dialects of Lisp, I wanted to get away from these high-level interpreted languages. And so I learned Rust. 
			While a little bit daunting at first, once you get the hang of it Rust really is an amazing language to work in. 
			It's low-level nature feels empowering, because you get to choose and - more importantly - understand your abstractions from the bottom up, without having to sacrifice much at all. </p>
			<p>I made a point of building my own projects with what I've learned. This isn't really something that I need to be told: I'm always really eager to take anything that I learn and put it through its paces immediately.  
			The downside of this tendency is that I often don't get to to the end of the explanation before I'm off doing my own thing. 
			But with Rust, not are the available explanations to the point, the language tooling teaches you the finer points and won't let you make most mistakes.
			The ecosystem is often said to be less-than mature, but especially as a learner this is a boon. Seeing and working with frameworks that are a little rough around the edges sometimes. Frameworks that will accept my pull requests even. And Frameworks that, in terms of stability and speed <em>still</em> run circles around everything else that's out there. </p> 
			<p>I spent more time than I care to admit on fiddling with EMacs. Especially org-mode is such a powerful tool. I still do a lot of my notetaking with orgmode. But unfortunately, at the end of the day, EMacs is not stable or fast enough to be a daily-drive work environment for me. When I need to get complex things done, I still reach for VSCode. I will get vim-movements set up in VSCode now, and perhaps switch to nvim down the line. </p>
		</article>

	</body>
</html>
